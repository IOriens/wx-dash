<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>路由</title>
  <link rel="stylesheet" href="../../style.css" />
  <link rel="stylesheet" href="../../website.css" />
  <style type="text/css">
    body {
      padding: 1em;
    }
  </style>
</head>
<body>
  
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="页面路由">页面路由</h1>
<p>在小程序中所有页面的路由全部由框架进行管理。</p>
<h3 id="页面栈">页面栈</h3>
<p>框架以栈的形式维护了当前的所有页面。
当发生路由切换的时候，页面栈的表现如下：</p>
<table>
<thead>
<tr>
<th>路由方式</th>
<th>页面栈表现</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始化</td>
<td>新页面入栈</td>
</tr>
<tr>
<td>打开新页面</td>
<td>新页面入栈</td>
</tr>
<tr>
<td>页面重定向</td>
<td>当前页面出栈，新页面入栈</td>
</tr>
<tr>
<td>页面返回</td>
<td>页面不断出栈，直到目标返回页，新页面入栈</td>
</tr>
<tr>
<td>Tab 切换</td>
<td>页面全部出栈，只留下新的 Tab 页面</td>
</tr>
<tr>
<td>重加载</td>
<td>页面全部出栈，只留下新的页面</td>
</tr>
</tbody>
</table>
<h3 id="getcurrentpages">getCurrentPages()</h3>
<p><code>getCurrentPages()</code> 函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。</p>
<p><strong>Tip：不要尝试修改页面栈，会导致路由以及页面状态错误。</strong></p>
<h3 id="路由方式">路由方式</h3>
<p>对于路由的触发方式以及页面生命周期函数如下：</p>
<table>
<thead>
<tr>
<th>路由方式</th>
<th>触发时机</th>
<th>路由前页面</th>
<th>路由后页面</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始化</td>
<td>小程序打开的第一个页面</td>
<td></td>
<td>onLoad, onShow</td>
</tr>
<tr>
<td>打开新页面</td>
<td>调用 API <a href="../../api/ui-navigate.html#wxnavigatetoobject"><code>wx.navigateTo</code></a> 或使用组件 <a href="../../component/navigator.html"><code><navigator open-type="navigateTo"/></code></a></td>
<td>onHide</td>
<td>onLoad, onShow</td>
</tr>
<tr>
<td>页面重定向</td>
<td>调用 API <a href="../../api/ui-navigate.html#wxredirecttoobject"><code>wx.redirectTo</code></a> 或使用组件 <a href="../../component/navigator.html"><code><navigator open-type="redirectTo"/></code></a></td>
<td>onUnload</td>
<td>onLoad, onShow</td>
</tr>
<tr>
<td>页面返回</td>
<td>调用 API <a href="../../api/ui-navigate.html#wxnavigateback"><code>wx.navigateBack</code></a> 或使用组件<a href="../../component/navigator.html"><code><navigator open-type="navigateBack"></code></a>或用户按左上角返回按钮</td>
<td>onUnload</td>
<td>onShow</td>
</tr>
<tr>
<td>Tab 切换</td>
<td>调用 API <a href="../../api/ui-navigate.html#wxswitchtab"><code>wx.switchTab</code></a> 或使用组件 <a href="../../component/navigator.html"><code><navigator open-type="switchTab"/></code></a> 或用户切换 Tab</td>
<td></td>
<td>各种情况请参考下表</td>
</tr>
<tr>
<td>重启动</td>
<td>调用 API <a href="../../api/ui-navigate.html#wxrelaunch"><code>wx.reLaunch</code></a> 或使用组件 <a href="../../component/navigator.html"><code><navigator open-type="reLaunch"/></code></a></td>
<td>onUnload</td>
<td>onLoad, onShow</td>
</tr>
</tbody>
</table>
<p>Tab 切换对应的生命周期（以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例）：</p>
<table>
<thead>
<tr>
<th>当前页面</th>
<th>路由后页面</th>
<th>触发的生命周期（按顺序）</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>A</td>
<td>Nothing happend</td>
</tr>
<tr>
<td>A</td>
<td>B</td>
<td>A.onHide(), B.onLoad(), B.onShow()</td>
</tr>
<tr>
<td>A</td>
<td>B（再次打开）</td>
<td>A.onHide(), B.onShow()</td>
</tr>
<tr>
<td>C</td>
<td>A</td>
<td>C.onUnload(), A.onShow()</td>
</tr>
<tr>
<td>C</td>
<td>B</td>
<td>C.onUnload(), B.onLoad(), B.onShow()</td>
</tr>
<tr>
<td>D</td>
<td>B</td>
<td>D.onUnload(), C.onUnload(), B.onLoad(), B.onShow()</td>
</tr>
<tr>
<td>D（从转发进入）</td>
<td>A</td>
<td>D.onUnload(), A.onLoad(), A.onShow()</td>
</tr>
<tr>
<td>D（从转发进入）</td>
<td>B</td>
<td>D.onUnload(), B.onLoad(), B.onShow()</td>
</tr>
</tbody>
</table>
<p><strong>Tips</strong>:</p>
<ul>
<li><code>navigateTo</code>, <code>redirectTo</code> 只能打开非 tabBar 页面。</li>
<li><code>switchTab</code> 只能打开 tabBar 页面。</li>
<li><code>reLaunch</code> 可以打开任意页面。</li>
<li>页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。</li>
<li>调用页面路由带的参数可以在目标页面的<code>onLoad</code>中获取。</li>
</ul>

                                
                                </section>
                            
    </div>
    
</div>

                        
</body>
</html>
